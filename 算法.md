# 算法

## 动态规划

### 股票问题

#### 一次买卖

![image-20230920123959039](https://img-blog.csdnimg.cn/d91db0acdbcd4727a536776d01d01f17.png)

> 算法思想：
>
> ​	因为只有一次买卖，不需要存储之前的状态，与动态规划关系不大。
>
> ​	考虑到顺序，定义一个minprice初始化为最大值，进行一次遍历，maxprofit初始化为0
>
> ​	进行判断，更新最小值已经最大利润

~~~cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int inf = 1e9;
        int minPrice = inf;
        int maxprofit = 0;
        int n = prices.size();
        for(int i = 0; i < n; i++){
            minPrice = min(prices[i] , minPrice);
            maxprofit = max(maxprofit, prices[i] - minPrice);
        }
        return maxprofit;
    }
};
~~~



---

#### 无限交易，最多持有一股

![image-20230920124506291](https://img-blog.csdnimg.cn/28eb9fb2d94f4288a7e3b22786b6170d.png)

> 思路：
>
> ​	基本的动态规划问题。dp[i] [0]:第i天不持有股票的最大利润。dp[i] [1]:第i天持有股票的最大利润。
>
> ​	状态转移方程：持有股票：可能是之前持有，也可能是今天买入，所以两种方式取最大值
>
> ​							不持有股票：同理，可能是之前就不持有，也可能是今天卖出

~~~cpp
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int dp[n][2];
        dp[0][0] = 0;
        dp[0][1] = -prices[0];
        for(int i = 1; i < n; i++){
            dp[i][0] = max(dp[i  -1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = max(dp[i - 1][0] - prices[i], dp[i - 1][1]);
        }
        return dp[n - 1][0];
    }
};
~~~

#### 两笔交易，最多持有一股

![image-20230920125417152](https://img-blog.csdnimg.cn/a8ebde21eb3543c18765fbd3735f8a80.png)

> 思路:
>
> ​	因为只能有两次，所以用dp[n] [4] 来记录四个状态，大致思路跟上题一样

~~~Cpp
int n = prices.size();
        if(n < 2){
            return 0;
        }
        vector<vector<int>> dp(n, vector<int>(5)); // 创建一个二维动态规划数组dp，其中dp[i][j]表示在第i天结束时，处于状态j时的最大利润
        dp[0][0] = 0; // 第一天不持有股票，利润为0
        dp[0][1] = -prices[0]; // 第一天持有股票，利润为-price[0]（购买股票的成本）
        dp[0][3] = -prices[0]; // 第一天持有股票且已进行过一次交易，利润为-price[0]

        for(int i = 1; i < n; i++){
            dp[i][1] = max(dp[i-1][1], -prices[i]); // 在第i天持有股票，可以是前一天就持有或者今天购买的最大利润
            dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i]); // 在第i天卖出股票，可以是前一天就卖出或者今天卖出的最大利润
            dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i]); // 在第i天持有股票且已进行过一次交易，可以是前一天就持有或者今天购买的最大利润
            dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i]); // 在第i天卖出股票且已进行过两次交易，可以是前一天就卖出或者今天卖出的最大利润
        }
        return dp[n - 1][4]; // 返回最终最大利润，即在第n天结束时且已经进行了两次交易的状态下
~~~

#### k次交易，最多持有一股

![image-20230920131206587](E:\Typora\pictures\image-20230920131206587.png)

> 思路：
>
> ​	与上一题基本相似，不同之处在于你需要将次数抽象成2 * k + 1；

~~~cpp
class Solution {
public:
    int maxProfit(int k, vector<int>& prices) {
        int n = prices.size();
        if(n < 2 || k == 0){
            return 0;
        }
        vector<vector<int>> dp(n,vector<int>(2 * k + 1));
        dp[0][0] = 0;
        int tmp = 1;
        while(tmp <= 2 * k){
            dp[0][tmp] = -prices[0]; 
            tmp += 2;
        }

        for(int i = 1; i < n; i++){
            for(int j = 1; j <= 2 * k; j += 2){
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] - prices[i]);
            }
            for(int j = 2; j <= 2 * k; j += 2){
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i]);
            }
        }
        
        int max_profit = 0;
        for(int i = 0; i <= 2 * k; i += 2){
            max_profit = max(max_profit, dp[n - 1][i]);
        }
        
        return max_profit;
    }
};
~~~



---

### 最长公共子序列

![image-20230920224238172](E:\Typora\pictures\image-20230920224238172.png)

> 思路：
>
> ​	确定状态转移方程：if(text1[i - 1] == text2[j - 1]){
>
> ​          dp[i][j] = dp[i - 1][j  -1] + 1;
>
> ​        }else{
>
> ​          dp[i][j] = max(dp[i - 1][j], max(dp[i][j - 1], dp[i - 1][ j - 1]));
>
> ​        }
>
> dp[i] [j] :表示前一个字符串的0-i位和后一个字符串的0-j位中最长的公共前缀
>
> 当t1[i] == t2[j] 时，该长度为之前长度+ 1
>
> 不相等时，另外三种情况取最大值(写的比较简略，详见代码逻辑)

~~~cpp
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        int n1 = text1.size();
        int n2 = text2.size();
        int dp[n1 + 1][n2 + 1];
        for(int i = 0; i <= n1; i++){
            dp[i][0] = 0;
        }
        for(int j = 0; j <= n2; j++){
            dp[0][j] = 0;
        }
        for(int i = 1; i <= n1; i++){
            for(int j = 1; j <= n2; j++){
                if(text1[i - 1] == text2[j - 1]){
                    dp[i][j] = dp[i - 1][j  -1] + 1;
                }else{
                    dp[i][j] = max(dp[i - 1][j], max(dp[i][j - 1], dp[i - 1][ j - 1]));
                }
            }
        }
        return dp[n1][n2];
    }
};
~~~

