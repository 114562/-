# 面试准备

## cpp基础部分

### STL

#### 标准模版的组成

* 1.容器(Container) 

> **数据结构**，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器。
>
> * list、deque、vector

* 2.算法(Algorithm)

> 是用来操作容器中数据的**模版函数**，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象， **函数本身与他们操作的数据的结构和类型无关**，因此他们可以用于从简单数组到高度复杂容器的任何数据结构上。

* 3.迭代器(Iterator)

> 提供了**访问容器中对象的方法**。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。 迭代器就如同一个指针。事实上，C++ 的指针也是一种迭代器。 但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符方法的类对象;

* 4.仿函数(Function object)

> * 仿函数又称之为**函数对象**， 其实就是**重载了操作符的struct,**没有什么特别的地方。

* 5.适配器（Adaptor）

> 简单的说就是**一种接口类**，专门用来修改现有类的接口，提供一中新的接口；或调用现有的函数来实现所需要的功能。主要包括3中适配器Container Adaptor、Iterator Adaptor、Function Adaptor

* 6.空间配制器（Allocator）

> 为STL提供空间配置的系统。其中主要工作包括两部分：
>
> * 对象的创建与销毁
> * 内存的获取与释放

#### STL中常见容器

* 顺序容器

  * vector

  > 底层使用**动态数组**，元素在内存中**连续存放**。
  >
  > **支持随机存取**元素，在尾端增删元素具有较佳的性能

  * deque

  > 底层使用**双向队列**，元素在内存中**连续存放**。
  >
  > **支持随机存取**元素，效率比vector略低，但也是常数时间。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。

  * list

  > 底层使用**双向链表**。元素在内存中**不连续存放**。
  >
  > **不支持随机存取**

* 关联式容器

  * set/multiset

  >  set 即集合。set中不允许相同元素，multiset中允许存在相同元素。

  * map/multimap

  > map与set的不同在于map中存放的元素有且仅有两个成员变，一个名为first,另一个名为second, **map根据first值对元素从小到大排序**，并可快速地根据first来检索元素
  >
  > **注意：**map同multimap的不同在于是否允许相同first值的元素。

* 适配性容器

  * 封装了一些基本的容器，使之具备了新的函数功能。比如把deque封装一下变为一个具有stack功能的数据结构。这新得到的数据结构就叫适配器。包含stack,queue,priority_queue
  * stack **FILO**

  > 栈是项的有限序列，并满足序列中被删除、检索和修改的项只能是最进插入序列的项（栈顶的项）。**后进先出。**

  * queue**FIFO**

  > 队列。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。**先进先出。**

  * priority_queue  

  > 优先级队列。内部维持某种有序，然后确保优先级最高的元素总是位于头部。**优先级最高的元素总是第一个出列**

---

####  map hashtable deque list 的实现原理

* map实现原理

  > 底层是**红黑树**(红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡的二叉搜索树)。红黑树有自动排序的功能。因此**map内所有元素都是有序的**。红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。**map中的元素是按照二叉树**（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。

* hashtable(散列表、哈希表)实现原理

  > hashtable采用了**函数映射**的思想记录的**存储位置与记录的关键字**，从而能够快速地进行查找。它同数组、链表以及二叉排序树等相比较有很明显的区别，它能够快速定位到想要查找的记录，而不是与表中存在的记录的关键字进行比较来进行查找。

* deque实现原理

  > 底层是**双向队列**，元素在内存中连续存放。支持随机存储？，所有适用于vector的操作都适用于deque。支持两端增删元素

* list实现原理

  > 底层是**双向链表**，元素在内存中随机存放，不支持随机存取。无成员函数，给定一个下表i，访问第i个元素的内容，只能从头部挨个遍历到第i个元素

---

#### 介绍一下 STL 的空间配置器（allocator）

* allocator是**用来实现内存空间分配的工具**，**每一种容器的空间分配都是通过分配器allocator实现的**

* 两种对象实例化方式
  * 1.利用构造函数，直接构造类对象tg Test test()
  * 2.通过new来实例化一个类对象。Test *pTest = new Test
* 两种实例化方式的异同
  * 内存分配的三种方式
    * **静态存储区分配**：内存在**程序编译的时候已经分配好了**。这块内存在程序的整个运行空间内都存在。如全局变量、静态变量等
    * **栈空间分配**：程序在运行期间，函数内的局部变量通过栈空间来分配存储(函数调用栈)，当函数执行完毕返回时，相对应的栈空间立即回收。主要是局部变量
    * **堆空间分配**：程序在运行期间，通过在**堆空间上为数据分配存储空间**，通过malloc和new创建的对象都是从堆空间分配内存，这类空间需要程序员自己来管理，必须通过free()或者是delete()函数对堆空间进行释放，否则会造成内存溢出。
  * 现在从分配的角度来区分两者的异同
    * 对于第一种方式来说，是直接通过调用Test类的**构造函数来实例化Test类对象**的,如果**该实例化对象是一个局部变量，则其是在栈空间分配相应的存储空间**。
    * 对于第二种方式来说,就显得比较复杂。这里主要以new类对象来说明一下。new一个类对象,其实是执行了两步操作：首先**,调用new在堆空间分配内存,**然后**调用类的构造函数构造对象**的内容；同样，使用delete释放时，也是经历了两个步骤：**首先调用类的析构函数释放类对象，然后调用delete释放堆空间。**
* **allocator空间适配器**的实现
  * 为了实现空间配置器，完全可以**利用new和delete函数并对其进行封装**实现STL的空间配置器，的确可以这样。但是这样效率低
  * STL中，将对象的构造切分开来，分成**空间配置**和**对象构造**两部分
    * 内存配置操作：通过alloc：allocate()实现
    * 内存释放操作：通过alloc::deallocate()实现 
    * 对象构造操作：通过::construct()实现 
    * 对象释放操作： 通过::destroy()实现
  * 关于内存空间的配置与释放，SGI STL采用了两级配置器：一级配置器主要是考虑大块内存空间，利用malloc和free实现；二级配置器主要是考虑小块内存空间而设计的（为了最大化解决内存碎片问题，进而提升效率），采用**链表free_list来维护内存池**（memory pool），**free_list通过union结构实现**，空闲的内存块互相挂接在一块，内存块一旦被使用，则被从链表中剔除，易于维护。

---

#### STL 容器用过哪些，查找的时间复杂度是多少

* STL中常用的容器有vector、deque、list、map、set、multimap、multiset、unordered_map、unordered_set等

> * vector：采用一维数组
>
>   * 插入：O(N)
>   * 查找：O(1)
>   * 删除：O(N)
>
> * deque：采用双向队列
>
>   * 插入：O(N)
>   * 查找：O(1)
>   * 删除：O(N)
>
> * list：采用双向链表
>
>   * 插入：O(1)
>   * 查找：O(N)
>   * 删除：O(1)
>
> * map、set、multiset、multimap
>
>   * 上述四种容器采用红黑树实现，红黑树是平衡二叉树的一种
>
>   * 插入：O(logN)
>   * 查找：O(logN)
>   * 删除：O(logN)
>
> * unordered_map、unordered_set、unordered_multimap、 unordered_multiset
>
>   * 上述四种容器采用哈希表实现
>
>   * 插入：最好O(1)，最坏O(N)
>   * 查找：最好O(1)，最坏O(N)
>   * 删除：最好O(1)，最坏O(N)

* **注意：**容器的时间复杂度取决于其底层实现方式。

---

#### 迭代器什么时候会失效？

* 1.对于序列容器vector，deque来说，**使用rease后，后面的每个元素的迭代器都会失效，**后面每个元素都往前移动一位，**erase返回下一个有效的迭代器**
* 2.对于关联容器map，set来说，**使用erase后，当前元素的迭代器失效**，但是其结构是红黑树，**删除当前元素，不会影响下一个元素的迭代器**，所以在调用erase之前，记录下一个元素的迭代器即可
* 对于list来说，它使用了不连续分配的内存，并且**它的erase方法也会返回下一个有效的迭代器**，因此上面两种方法都可以使用。

---

#### 迭代器和指针的区别

* 迭代器的作用：

  > * 用于**指向顺序容器和关联容器中的元素**
  > * 通过迭代器可以读取它指向的元素
  > * 通过非const迭代器还可以修改其指向的元素

* 两者区别

  > **迭代器是类模版，不是指针！**，迭代器的行为很像指针，重载了指针的一些操作符：->,++,--等。
  >
  > 迭代器封装了指针，是一个”可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象，**本质**是**封装了原生指针**，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，--等操作。
  >
  > **迭代器返回的是对象引用而不是对象的值**，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身。

* 迭代器产生的原因

  * iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。

* 容器已经容器的迭代器类别

  | 容器           | 容器上的迭代器类别 |
  | -------------- | ------------------ |
  | vector         | 随机访问           |
  | deque          | 随机访问           |
  | list           | 双向               |
  | set/multiset   | 双向               |
  | map/multimap   | 双向               |
  | stack          | 不支持迭代器       |
  | queue          | 不支持迭代器       |
  | priority_queue | 不支持迭代器       |

#### STL 中 resize 和 reserve 的区别

* 两个概念

  * capacity：该值在容器初始化时赋值，指的是容器能够容纳的最大的元素个数，还**不能通过下标等访问**，因为此时容器中还没有创建任何对象。

  * size：是此时容器中元素的个数，可以通过下标访问0-(size-1)访问

  * **resize既修改capacity大小，也修改size大小，reserve只修改capacity大小，不修改size大小**

  * 两者的形参个数不一样。 resize带两个参数，一个表示容器大小，一个表示初始值（默认为0）；reserve只带一个参数，表示容器预留的大小。

  * resize 和 reserve 既有差别，也有共同点。两个接口的**共同点**是**它们都保证了vector的空间大小(capacity)最少达到它的参数所指定的大小。**下面就他们的细节进行分析

  *  为实现resize的语义，resize接口做了两个保证：

    ​    （1）保证区间[0, new_size)范围内数据有效，如果下标index在此区间内，vector[indext]是合法的；
  
    ​    （2）保证区间[0, new_size)范围以外数据无效，如果下标index在区间外，vector[indext]是非法的

 		     	reserve只是保证vector的空间大小(capacity)最少达到它的参数所指定的大小n。在区间[0, n)范围内，如果下标是index，vector[index]这种访问有可能是合法的，也有可能是非法的，视具体情况而定

* reserve只是保证vector的空间大小(capacity)最少达到它的参数所指定的大小n。在区间[0, n)范围内，如果下标是index，vector[index]这种访问有可能是合法的，也有可能是非法的，视具体情况而定

#### map和unordered_map的区别

* map实现原理

> map底层是**红黑树**，红黑树有自动排序的功能，因此map内部所有元素是有序的。map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。

* unordered_map实现原理

> unordered_map底层是**哈希表**，通过关键码值映射到Hash表中一个位置来访问记录。查找时间复杂度可以为O(1)，元素是无序的

#### vector 和 list 的区别

* vector

> 底层是一维数组，支持随机访问，容器空间不足时需要扩容

* list

> 底层是双向链表，只能通过指针来访问，没有重载[]

* 应用场景
  * vector：拥有一段连续的内存空间，需要高效的随机访问，不在乎插入和删除的效率使用vector
  * list：拥有一段不连续的内存空间，需要高效的插入和删除，不关系随机访问使用list

#### vector插入删除迭代器

> **底层一维数组**

* 新增元素

> 若集合已满，则在新增数据的时候，需要另外找一块更大的内存，将原来的数据拷贝，释放之前的内存。插入可以分为push_back插在最后和迭代器插入任意位置。通过迭代器与第一个位置的距离相比得出要插入的位置，该元素后面的所有元素都要向后移动一个位置，在空出来的位置上存入新的元素

```cpp
//新增元素  
void insert(const_iterator iter,const T& t ) {
    int index=iter-begin();  
    if (index<size_) {   
        if (size_==capacity_)   {    
            int capa=calculateCapacity();   
            newCapacity(capa);   
        }   
        memmove(buf+index+1,buf+index,(size_-index)*sizeof(T));    
        buf[index]=t; 
        size_++;  
    } 
}
```

* 插入元素

> 通过删除最后一个元素pop_back()和迭代器删除任意一个元素erase(iter);
>
> 通过迭代器删除还是先找到要删除元素的位置，即int index=iter-begin();这个位置后面的每个元素都想前移动一个元素的位置。同时我们知道**erase不释放内存只初始化成默认值。**
>
> 删除全部元素使用clear，只是循环调用了erase，不释放内存，内存是在析构函数中释放的

~~~cpp
//删除元素  
iterator erase(const_iterator iter) {
	int index=iter-begin();      
	if (index<size_ && size_>0)     {
		memmove(buf+index ,buf+index+1,(size_-index)*sizeof(T));          
		buf[--size_]=T();    
	}      
	return iterator(iter); 
} 
~~~

### STL新特性

> 主要包括含语法改进和标准库扩充两个方面，主要有11点

* ![image-20230916220414374](https://img-blog.csdnimg.cn/130f639b19c44661b27511c508c65f99.png)

* 1.语法的新特性

  > 1.统一的初始化方法
  >
  > 2.成员变量默认初始化
  >
  > 3**.auto关键字**
  >
  > 4**.decltype 求表达式的类型**
  >
  > **5.智能指针 shared_ptr**
  >
  > **6.空指针nullptr**
  >
  > **7.基于返回的for循环**
  >
  > 8**.右值引用和move语义**，让程序员有意识的减少深拷贝

* 2.标准库扩充

  > 1.无需容器(**哈希表)**：用法和功能跟map，**区别在于哈希表的效率更高**
  >
  > 2.**正则表达式**：正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串
  >
  > 3,。**lambda表达式**

* auto和decltype区别

  ```cpp
  auto varname = value; decltype(exp) varname = value;
  ```

  * 其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式。

      auto 根据"="右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟"="右边的 value 没有关系。

  * 另外，auto 要求变量必须初始化，而 decltype 不要求。这很容易理解，auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。decltype 可以写成下面的形式：

    ```cpp
    decltype(exp) varname;
    // decltype 用法举例 
    int a = 0; decltype(a) b = 1;  //b 被推导成了 int 
    decltype(10.8) x = 5.5;  //x 被推导成了 double 
    decltype(x + 100) y;  //y 被推导成了 double
    
    ```

* 智能指针 shared ptr

  * **智能指针可以共同使用同一块堆内存**，并且智能指针采用**引用计数机制**，，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针。(只有引用计数为0，堆内存才会被自动释放)

  ```cpp
  #include <iostream> #include <memory> 
  using namespace std; 
  int main() {     
      //构建 2 个智能指针     
      std::shared_ptr<int> p1(new int(10));     
      std::shared_ptr<int> p2(p1);     
      //输出 p2 指向的数据     
      cout << *p2 << endl;     
      p1.reset();
      //引用计数减 1,p1为空指针     
      if (p1) {         
          cout << "p1 不为空" << endl;     
      }else {        
          cout << "p1 为空" << endl;     
      }     
      //以上操作，并不会影响 p2     
      cout << *p2 << endl;     
      //判断当前和 p2 同指向的智能指针有多少个    
      cout << p2.use_count() << endl;    
      return 0; 
  }  /*      程序运行结果：          10  p1 为空  10  1  */          
  ```

* **空指针 nullptr（原来NULL**）

  * 

























