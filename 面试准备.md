# 面试准备

## cpp基础部分

### STL

#### 标准模版的组成

* 1.容器(Container) 

> **数据结构**，以模板类的方法提供。为了访问容器中的数据，可以使用由容器类输出的迭代器。
>
> * list、deque、vector

* 2.算法(Algorithm)

> 是用来操作容器中数据的**模版函数**，STL用sort()来对一个vector中的数据进行排序，用find()来搜索一个list中的对象， **函数本身与他们操作的数据的结构和类型无关**，因此他们可以用于从简单数组到高度复杂容器的任何数据结构上。

* 3.迭代器(Iterator)

> 提供了**访问容器中对象的方法**。例如，可以使用一对迭代器指定list或vector中的一定范围的对象。 迭代器就如同一个指针。事实上，C++ 的指针也是一种迭代器。 但是，迭代器也可以是那些定义了operator*()以及其他类似于指针的操作符方法的类对象;

* 4.仿函数(Function object)

> * 仿函数又称之为**函数对象**， 其实就是**重载了操作符的struct,**没有什么特别的地方。

* 5.适配器（Adaptor）

> 简单的说就是**一种接口类**，专门用来修改现有类的接口，提供一中新的接口；或调用现有的函数来实现所需要的功能。主要包括3中适配器Container Adaptor、Iterator Adaptor、Function Adaptor

* 6.空间配制器（Allocator）

> 为STL提供空间配置的系统。其中主要工作包括两部分：
>
> * 对象的创建与销毁
> * 内存的获取与释放

#### STL中常见容器

* 顺序容器

  * vector

  > 底层使用**动态数组**，元素在内存中**连续存放**。
  >
  > **支持随机存取**元素，在尾端增删元素具有较佳的性能

  * deque

  > 底层使用**双向队列**，元素在内存中**连续存放**。
  >
  > **支持随机存取**元素，效率比vector略低，但也是常数时间。在两端增删元素具有较佳的性能（大部分情况下是常数时间）。

  * list

  > 底层使用**双向链表**。元素在内存中**不连续存放**。
  >
  > **不支持随机存取**

* 关联式容器

  * set/multiset

  >  set 即集合。set中不允许相同元素，multiset中允许存在相同元素。

  * map/multimap

  > map与set的不同在于map中存放的元素有且仅有两个成员变，一个名为first,另一个名为second, **map根据first值对元素从小到大排序**，并可快速地根据first来检索元素
  >
  > **注意：**map同multimap的不同在于是否允许相同first值的元素。

* 适配性容器

  * 封装了一些基本的容器，使之具备了新的函数功能。比如把deque封装一下变为一个具有stack功能的数据结构。这新得到的数据结构就叫适配器。包含stack,queue,priority_queue
  * stack **FILO**

  > 栈是项的有限序列，并满足序列中被删除、检索和修改的项只能是最进插入序列的项（栈顶的项）。**后进先出。**

  * queue**FIFO**

  > 队列。插入只可以在尾部进行，删除、检索和修改只允许从头部进行。**先进先出。**

  * priority_queue  

  > 优先级队列。内部维持某种有序，然后确保优先级最高的元素总是位于头部。**优先级最高的元素总是第一个出列**

---

####  map hashtable deque list 的实现原理

* map实现原理

  > 底层是**红黑树**(红黑树是非严格平衡的二叉搜索树，而AVL是严格平衡的二叉搜索树)。红黑树有自动排序的功能。因此**map内所有元素都是有序的**。红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。**map中的元素是按照二叉树**（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。

* hashtable(散列表、哈希表)实现原理

  > hashtable采用了**函数映射**的思想记录的**存储位置与记录的关键字**，从而能够快速地进行查找。它同数组、链表以及二叉排序树等相比较有很明显的区别，它能够快速定位到想要查找的记录，而不是与表中存在的记录的关键字进行比较来进行查找。

* deque实现原理

  > 底层是**双向队列**，元素在内存中连续存放。支持随机存储？，所有适用于vector的操作都适用于deque。支持两端增删元素

* list实现原理

  > 底层是**双向链表**，元素在内存中随机存放，不支持随机存取。无成员函数，给定一个下表i，访问第i个元素的内容，只能从头部挨个遍历到第i个元素

---

#### 介绍一下 STL 的空间配置器（allocator）

* allocator是**用来实现内存空间分配的工具**，**每一种容器的空间分配都是通过分配器allocator实现的**

* 两种对象实例化方式
  * 1.利用构造函数，直接构造类对象tg Test test()
  * 2.通过new来实例化一个类对象。Test *pTest = new Test
* 两种实例化方式的异同
  * 内存分配的三种方式
    * **静态存储区分配**：内存在**程序编译的时候已经分配好了**。这块内存在程序的整个运行空间内都存在。如全局变量、静态变量等
    * **栈空间分配**：程序在运行期间，函数内的局部变量通过栈空间来分配存储(函数调用栈)，当函数执行完毕返回时，相对应的栈空间立即回收。主要是局部变量
    * **堆空间分配**：程序在运行期间，通过在**堆空间上为数据分配存储空间**，通过malloc和new创建的对象都是从堆空间分配内存，这类空间需要程序员自己来管理，必须通过free()或者是delete()函数对堆空间进行释放，否则会造成内存溢出。
  * 现在从分配的角度来区分两者的异同
    * 对于第一种方式来说，是直接通过调用Test类的**构造函数来实例化Test类对象**的,如果**该实例化对象是一个局部变量，则其是在栈空间分配相应的存储空间**。
    * 对于第二种方式来说,就显得比较复杂。这里主要以new类对象来说明一下。new一个类对象,其实是执行了两步操作：首先**,调用new在堆空间分配内存,**然后**调用类的构造函数构造对象**的内容；同样，使用delete释放时，也是经历了两个步骤：**首先调用类的析构函数释放类对象，然后调用delete释放堆空间。**
* **allocator空间适配器**的实现
  * 为了实现空间配置器，完全可以**利用new和delete函数并对其进行封装**实现STL的空间配置器，的确可以这样。但是这样效率低
  * STL中，将对象的构造切分开来，分成**空间配置**和**对象构造**两部分
    * 内存配置操作：通过alloc：allocate()实现
    * 内存释放操作：通过alloc::deallocate()实现 
    * 对象构造操作：通过::construct()实现 
    * 对象释放操作： 通过::destroy()实现
  * 关于内存空间的配置与释放，SGI STL采用了两级配置器：一级配置器主要是考虑大块内存空间，利用malloc和free实现；二级配置器主要是考虑小块内存空间而设计的（为了最大化解决内存碎片问题，进而提升效率），采用**链表free_list来维护内存池**（memory pool），**free_list通过union结构实现**，空闲的内存块互相挂接在一块，内存块一旦被使用，则被从链表中剔除，易于维护。

---

#### STL 容器用过哪些，查找的时间复杂度是多少

* STL中常用的容器有vector、deque、list、map、set、multimap、multiset、unordered_map、unordered_set等

> * vector：采用一维数组
>
>   * 插入：O(N)
>   * 查找：O(1)
>   * 删除：O(N)
>
> * deque：采用双向队列
>
>   * 插入：O(N)
>   * 查找：O(1)
>   * 删除：O(N)
>
> * list：采用双向链表
>
>   * 插入：O(1)
>   * 查找：O(N)
>   * 删除：O(1)
>
> * map、set、multiset、multimap
>
>   * 上述四种容器采用红黑树实现，红黑树是平衡二叉树的一种
>
>   * 插入：O(logN)
>   * 查找：O(logN)
>   * 删除：O(logN)
>
> * unordered_map、unordered_set、unordered_multimap、 unordered_multiset
>
>   * 上述四种容器采用哈希表实现
>
>   * 插入：最好O(1)，最坏O(N)
>   * 查找：最好O(1)，最坏O(N)
>   * 删除：最好O(1)，最坏O(N)

* **注意：**容器的时间复杂度取决于其底层实现方式。

---

#### 迭代器什么时候会失效？

* 1.对于序列容器vector，deque来说，**使用rease后，后面的每个元素的迭代器都会失效，**后面每个元素都往前移动一位，**erase返回下一个有效的迭代器**
* 2.对于关联容器map，set来说，**使用erase后，当前元素的迭代器失效**，但是其结构是红黑树，**删除当前元素，不会影响下一个元素的迭代器**，所以在调用erase之前，记录下一个元素的迭代器即可
* 对于list来说，它使用了不连续分配的内存，并且**它的erase方法也会返回下一个有效的迭代器**，因此上面两种方法都可以使用。

---

#### 迭代器和指针的区别

* 迭代器的作用：

  > * 用于**指向顺序容器和关联容器中的元素**
  > * 通过迭代器可以读取它指向的元素
  > * 通过非const迭代器还可以修改其指向的元素

* 两者区别

  > **迭代器是类模版，不是指针！**，迭代器的行为很像指针，重载了指针的一些操作符：->,++,--等。
  >
  > 迭代器封装了指针，是一个”可遍历STL（ Standard Template Library）容器内全部或部分元素”的对象，**本质**是**封装了原生指针**，是指针概念的一种提升，提供了比指针更高级的行为，相当于一种智能指针，他可以根据不同类型的数据结构来实现不同的++，--等操作。
  >
  > **迭代器返回的是对象引用而不是对象的值**，所以cout只能输出迭代器使用取值后的值而不能直接输出其自身。

* 迭代器产生的原因

  * iterator类的访问方式就是把不同集合类的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到循环遍历集合的效果。

* 容器已经容器的迭代器类别

  | 容器           | 容器上的迭代器类别 |
  | -------------- | ------------------ |
  | vector         | 随机访问           |
  | deque          | 随机访问           |
  | list           | 双向               |
  | set/multiset   | 双向               |
  | map/multimap   | 双向               |
  | stack          | 不支持迭代器       |
  | queue          | 不支持迭代器       |
  | priority_queue | 不支持迭代器       |

#### STL 中 resize 和 reserve 的区别

* 两个概念

  * capacity：该值在容器初始化时赋值，指的是容器能够容纳的最大的元素个数，还**不能通过下标等访问**，因为此时容器中还没有创建任何对象。

  * size：是此时容器中元素的个数，可以通过下标访问0-(size-1)访问

  * **resize既修改capacity大小，也修改size大小，reserve只修改capacity大小，不修改size大小**

  * 两者的形参个数不一样。 resize带两个参数，一个表示容器大小，一个表示初始值（默认为0）；reserve只带一个参数，表示容器预留的大小。

  * resize 和 reserve 既有差别，也有共同点。两个接口的**共同点**是**它们都保证了vector的空间大小(capacity)最少达到它的参数所指定的大小。**下面就他们的细节进行分析

  *  为实现resize的语义，resize接口做了两个保证：

    ​    （1）保证区间[0, new_size)范围内数据有效，如果下标index在此区间内，vector[indext]是合法的；
  
    ​    （2）保证区间[0, new_size)范围以外数据无效，如果下标index在区间外，vector[indext]是非法的

 		     	reserve只是保证vector的空间大小(capacity)最少达到它的参数所指定的大小n。在区间[0, n)范围内，如果下标是index，vector[index]这种访问有可能是合法的，也有可能是非法的，视具体情况而定

* reserve只是保证vector的空间大小(capacity)最少达到它的参数所指定的大小n。在区间[0, n)范围内，如果下标是index，vector[index]这种访问有可能是合法的，也有可能是非法的，视具体情况而定

#### map和unordered_map的区别

* map实现原理

> map底层是**红黑树**，红黑树有自动排序的功能，因此map内部所有元素是有序的。map进行的查找、删除、添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉树（又名二叉查找树、二叉排序树）存储的，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值。使用中序遍历可将键值按照从小到大遍历出来。

* unordered_map实现原理

> unordered_map底层是**哈希表**，通过关键码值映射到Hash表中一个位置来访问记录。查找时间复杂度可以为O(1)，元素是无序的

#### vector 和 list 的区别

* vector

> 底层是一维数组，支持随机访问，容器空间不足时需要扩容

* list

> 底层是双向链表，只能通过指针来访问，没有重载[]

* 应用场景
  * vector：拥有一段连续的内存空间，需要高效的随机访问，不在乎插入和删除的效率使用vector
  * list：拥有一段不连续的内存空间，需要高效的插入和删除，不关系随机访问使用list

#### vector插入删除迭代器

> **底层一维数组**

* 新增元素

> 若集合已满，则在新增数据的时候，需要另外找一块更大的内存，将原来的数据拷贝，释放之前的内存。插入可以分为push_back插在最后和迭代器插入任意位置。通过迭代器与第一个位置的距离相比得出要插入的位置，该元素后面的所有元素都要向后移动一个位置，在空出来的位置上存入新的元素

```cpp
//新增元素  
void insert(const_iterator iter,const T& t ) {
    int index=iter-begin();  
    if (index<size_) {   
        if (size_==capacity_)   {    
            int capa=calculateCapacity();   
            newCapacity(capa);   
        }   
        memmove(buf+index+1,buf+index,(size_-index)*sizeof(T));    
        buf[index]=t; 
        size_++;  
    } 
}
```

* 插入元素

> 通过删除最后一个元素pop_back()和迭代器删除任意一个元素erase(iter);
>
> 通过迭代器删除还是先找到要删除元素的位置，即int index=iter-begin();这个位置后面的每个元素都想前移动一个元素的位置。同时我们知道**erase不释放内存只初始化成默认值。**
>
> 删除全部元素使用clear，只是循环调用了erase，不释放内存，内存是在析构函数中释放的

~~~cpp
//删除元素  
iterator erase(const_iterator iter) {
	int index=iter-begin();      
	if (index<size_ && size_>0)     {
		memmove(buf+index ,buf+index+1,(size_-index)*sizeof(T));          
		buf[--size_]=T();    
	}      
	return iterator(iter); 
} 
~~~

### STL新特性

> 主要包括含语法改进和标准库扩充两个方面，主要有11点

* ![image-20230916220414374](https://img-blog.csdnimg.cn/130f639b19c44661b27511c508c65f99.png)

* 1.语法的新特性

  > 1.统一的初始化方法
  >
  > 2.成员变量默认初始化
  >
  > 3**.auto关键字**
  >
  > 4**.decltype 求表达式的类型**
  >
  > **5.智能指针 shared_ptr**
  >
  > **6.空指针nullptr**
  >
  > **7.基于返回的for循环**
  >
  > 8**.右值引用和move语义**，让程序员有意识的减少深拷贝

* 2.标准库扩充

  > 1.无需容器(**哈希表)**：用法和功能跟map，**区别在于哈希表的效率更高**
  >
  > 2.**正则表达式**：正则表达式实质上是一个字符串，该字符串描述了一种特定模式的字符串
  >
  > 3,。**lambda表达式**

* auto和decltype区别

  ```cpp
  auto varname = value; decltype(exp) varname = value;
  ```

  * 其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式。

      auto 根据"="右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟"="右边的 value 没有关系。

  * 另外，auto 要求变量必须初始化，而 decltype 不要求。这很容易理解，auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。decltype 可以写成下面的形式：

    ```cpp
    decltype(exp) varname;
    // decltype 用法举例 
    int a = 0; decltype(a) b = 1;  //b 被推导成了 int 
    decltype(10.8) x = 5.5;  //x 被推导成了 double 
    decltype(x + 100) y;  //y 被推导成了 double
    
    ```

* 智能指针 shared ptr

  * **智能指针可以共同使用同一块堆内存**，并且智能指针采用**引用计数机制**，，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针。(只有引用计数为0，堆内存才会被自动释放)

  ```cpp
  #include <iostream> #include <memory> 
  using namespace std; 
  int main() {     
      //构建 2 个智能指针     
      std::shared_ptr<int> p1(new int(10));     
      std::shared_ptr<int> p2(p1);     
      //输出 p2 指向的数据     
      cout << *p2 << endl;     
      p1.reset();
      //引用计数减 1,p1为空指针     
      if (p1) {         
          cout << "p1 不为空" << endl;     
      }else {        
          cout << "p1 为空" << endl;     
      }     
      //以上操作，并不会影响 p2     
      cout << *p2 << endl;     
      //判断当前和 p2 同指向的智能指针有多少个    
      cout << p2.use_count() << endl;    
      return 0; 
  }  /*      程序运行结果：          10  p1 为空  10  1  */          
  ```

* **空指针 nullptr（原来NULL**）

  * nullptr是nullptr_t的**右值常量**，专门用于初始化控类型指针。
  * nullptr可以被隐式的转换成任意的指针类型
  
  > ```
  > int * a1 = nullptr;
  > char * a2 = nullptr;
  > double * a3 = nullptr;
  > ```

* **move**

  > 将一个左值强制转换为右值而**不进行实际的拷贝操作**
  >
  > move(arg); // 返回arg对象的右值形式
  >
  > 对于容器、智能指针、字符串等具有资源管理的对象非常有用

  ~~~cpp
  #include <iostream>
  #include <vector>
  
  int main() {
      std::vector<int> source = {1, 2, 3};
  
      // 使用 std::move 将 source 的内容移动到 target
      std::vector<int> target = std::move(source);
  
      std::cout << "Target size: " << target.size() << std::endl; // 输出：Target size: 3
      std::cout << "Source size: " << source.size() << std::endl; // 输出：Source size: 0
  
      return 0;
  }
  ~~~

* 无序容器(**哈希表**)

  * 用法和功能跟map一样，**但是哈希表效率更高**
  * 特点

  > 1.无序容器内部存储的**键值对都是无序的**，各键值对的存储位置取决于该键值对中的键
  >
  > 2.与关联式容器相比，无序容器擅长通过指定键查找对应的值，但对于使用迭代器遍历容器中存储的元素，无序容器执行效率比关联式容器效率低

  ![image-20230920112447277](https://img-blog.csdnimg.cn/e9f369886e63462f81d61c4af89ef450.png)

* 正则表达式

  > 实质是一个字符串，该字符串描述了一种特定模式的字符串，常用的符号如下：

![image-20230920114720389](https://img-blog.csdnimg.cn/7b2eb986cb584d2198ad6e21f2f8c7bc.png)

* lambda匿名函数

  > 格式：
  >
  > ​	[外部变量访问方式说明符] (**参数**) mutable noexcept/throw() -> 返回值类型     {      函数体;     };
  >
  > * 各部分解释：
  >   * []:用于向编译器表明当前是一个lambda表达式，**其不能被省略**。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。
  >     * 外部变量：指的是和当前 lambda 表达式位于**同一作用域内的所有局部变量**
  >   * ()：参数。和普通函数的定义一样，lambda 匿名函数也可以**接收外部传递的多个参数**。和普通函数不同的是，**如果不需要传递参数，可以连同 () 小括号一起省略**
  >   * mutable：此关键词可省略。如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于**以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值**（可以理解为这部分变量都是 const 常量）。而如果**想修改它们，就必须使用 mutable 关键字**
  >     * 注意，值传递不会修改变量本身
  >   * noexcept/throw()： 可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 **noexcept 关键字**，则表示函数体内**不会抛出任何异常**；使用 **throw() 可以指定 lambda 函数内部可以抛出的异常类型。**
  >   * -> :返回值类型。指明 lambda 匿名函数的返回值类型。，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略"-> 返回值类型"
  >   * {}：函数体   和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。

* **智能指针的内存泄漏**
  * 当两个对象使用一个shared_ptr指向地方时，会造成循环引用，使引用计数失效，从而导致内存泄漏
  * 使用weak_ptr解决

---

* c++11的**四种类型转换**

> const_cast、static_cast、dynamic_cast、reinterpret_cast

* const_cast
  * 将const变量转换为非const
* static_cast
  * **最常用**，可用于各种隐式转换。比如非const转const，static_cast可以用于类向上转换，但向下转换能成功但是不安全。
* dynamic_cast
  * **只能**用于含有虚函数的类转换，用于类向上和向下转换
  * **向上转换：**指子类向基类转换。  
  * **向下转换：**指基类向子类转换
  * 当父类转换成子类时可能出现非法内存访问的问题。当父类转换成子类时可能出现非法内存访问的问题。
* reinterpret_cast
  *  reinterpret_cast可以做任何类型的转换，不过不对转换结果保证，容易出问题。
* 注意：强制转换虽然功能强大，但是转换不够明确，不能检查错误。



## 操作系统

### 软连接和硬链接

* 定义不同

> * 软连接又叫符号链接，这个文件**包含了另一个文件的路径名。**可以是任意文件或目录，可以链接不同文件系统的文件
>
> * 硬链接就是一个文件的一个或多个文件名。把文件名和计算机文件系统使用的节点号链接起来。因此我们**可以用多个文件名与同一个文件进行链接**，这些文件名可以在同一目录或不同目录。

* 限制不同
  * **硬链接只能对已存在的文件进行创建**，不能交叉文件系统进行硬链接的创建
  * 软链接可对不存在的文件或目录创建软链接；可交叉文件系统
* 创建方式不同
  * 硬链接不能对目录进行创建，只可对文件创建
  * 软链接可对文件或目录创建
* 影响不同
  * 删除一个硬链接并不影响其他有相同inode号的文件
  * 删除软链接并不影响被指向的文件，但若被指向的源文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。

### 动态库和静态库的制作及区别

* 静态库的制作

~~~
gcc hello.c  -c //这样就生成hello.o目标文件 
ar rcs libhello.a  hello.o //生成libhello.a静态库
~~~

* 静态库使用

~~~
gcc main.c -lhello -o staticLibrary //main.c和hello静态库链接，生成staticLibrary执行文件
/*     
	 main.c：是指main主函数     
	-lhello：是我们生成的.a 文件砍头去尾（lib不要 .a也不要）前面加-l    
    -L：是指告诉gcc编译器先从-L指定的路径去找静态库，默认是从/usr/lib/ 或者  /usr/local/lib/ 去找。    
    ./：是指当前路径的意思     
    staticLibrary：是最后想生成的文件名（这里可随意起名字） 
*/

~~~

* 动态库制作

~~~
gcc -shared -fpic hello.c -o libhello.so
	-shared 指定生成动态库 
	-fpic ：fPIC选项作用于编译阶段，在生成目标文件时就得使用该选项，以生成位置无关的代码。

~~~

* 动态库使用

~~~
gcc main.c -lhello -L ./ -o dynamicDepot 
/*     
	main.c：是指main主函数     
	-lhello：是我们生成的.so 文件砍头去尾（lib不要 .so也不要）前面加-l     
	-L：是指告诉gcc编译器先从-L指定的路径去找静态库，默认是从/usr/lib/ 或者 /usr/local/lib/ 去找。     
	./：是指当前路径的意思     
	dynamicDepot：是最后想生成的文件名（这里可随意起名字） 
*/

~~~

* 两者区别
  * 静态库代码装载的速度快，执行速度略比动态库快
  * 动态库更节省内存，可执行文件体积比静态库小很多
  * **静态库是在编译时加载，动态库是在运行时加载**
  * 生成的静态链接库，windows下以**.lib**为后缀，Linux下以**.a**为后缀
  * 生成的动态链接库，windows下以**.dll**为后缀，Linux下以**.so**为后缀



### GDB调试命令

* GDB调试

> fdb调试的是**可执行文件**，在gcc编译时加入 **-g**，告诉gcc在**编译时加入调试信息**，这样gdb才能调试这个被编译的文件gcc -g test.c -o test

* GDB命令格式
  * quit：退出gdb
  * list：查看程序源代码
  * reverse-search：字符串用来从当前行向前查找第一个匹配的字符窜
* run：程序开始执行
* help list/all：
  * 查看帮助信息
* break： 设置断点
  * break 7：在第七行设置断点
  * break get_num：以函数名设置断点
  * break 行号或者函数名 if 条件：以条件表达式设置断点
* watch条件表达式：条件表达式发生改变时程序就会停下来
* next：继续执行下一条语句，**会把函数当做一条语句执行**
* step：继续执行下一条语句，会跟踪进入函数，**一次执行函数内的代码**

![image-20230925130826053](https://img-blog.csdnimg.cn/e3638042a85b472c97f5a0b4e8bf7c30.png)



### 网络字节序

* 小端

> **低**的有效字节存储在**低的**存储器地址。小端一般为主机字节序；常用的X86结构是小端模式。很多的ARM，DSP都为小端模式

* 大端

> **低**的有效字节存储在**低的**存储器地址。小端一般为主机字节序；常用的X86结构是小端模式。很多的ARM，DSP都为小端模式

* 网络字节序

> 网络上传输的数据都是**字节流**
>
> * UDP/TCP/IP协议规定:把接收到的第一个字节当作**高位**字节看待,这就要求发送端发送的第一个字节是高位字节;
>   * 即TCP等协议是**大端协议**



### 虚拟内存

* 存储系统为每一个进程分配一个独立的地址空间，虚拟内存与物理内存存在映射关系，通过**页表**寻址完成虚拟地址和物理地址的转换

### 内核态和用户态

> 内核态和用户态是操作系统的两种运行级别

* 系统态、内核态：

  * 拥有最高权限，可以访问所有系统指令，用户态则只能访问一部分指令
  * 进入内核态的三种方式

  > 1.系统调用：主动的
  >
  > 2.异常：被动的
  >
  > 3.设备中断：被动的

### 进程、线程、协程

* 进程
  * 进程是由程序段、数据段和PCB组成的，是程序运行的实例。
* 线程
  * 一个进程里的执行单元。一个进程里包含多个线程并发执行任务
* 协程
  * 一个线程包含多个协程，在子程序内部执行，可在子程序内部中断，转而执行别的子程序，在适当的时候再返回来接着执行

### fork()函数

* 创建一个子进程

>创建成功会在父进程中返回对应子进程的pid
>
>在子进程中返回0
>
>失败返回-1

> fork函数创建一个新进程后，会为这个新进程分配进程空间，将父进程的进程空间中的内容复制到子进程的空间中，包括父进程的数据段和堆栈段，并且和父进程共享代码段。这时候，子进程和父进程一模一样，都接受系统的调度。因为两个进程都停留在fork()函数中，**最后fork()函数会返回两次，一次在父进程中返回，一次在子进程中返回**，两次返回的值不一样，如上面的三种情况。

---

### 守护进程

> 守护进程是运行在后台的一种生存期长的特殊进程

* 实现：
  * 1.创建子进程，终止父进程。
    * fork()之后推出父进程
  * 2.调用setid()创建一个新会话
  * 3.将当前目录更改为根目录。子进程也进程了父进程的当前工作目录
  * 4.重设文件权限掩码
  * 5.关闭不再需要的文件描述符。子进程从父进程继承打开的文件描述符

### 进程通信

![image-20230925203021480](https://img-blog.csdnimg.cn/fc8b7be421194365877c883f983a2ff5.png)



























## 设计模式

### 单例模式

> 保证一个类**仅有一个实例**，并**提供一个访问它的全局访问点。**该实例被所有程序模块**共享**

* 单例模式有以下特点
  * 该类不能被复制
  * 该类不能被公开创造
  * 构造函数、拷贝构造函数和赋值函数必须是私有的

* 单例模式实现方式

> 单例模式通常分为**懒汉式单例**和**饿汉式单例**

* 懒汉式设计模式实现

  > **第一次访问时才会创建实例**
  >
  > 懒汉模式**线程不安全**

  * 1.静态指针 + 用到时初始化
  * 2.局部静态变量

~~~cpp
#include <iostream>
using namespace std;

class Singleton {
private:
    // 静态成员变量，用于保存唯一实例
    static Singleton* instance;
    int data;  // 单例对象的数据

    // 构造函数私有，放置外部创建对象
    Singleton() : data(0) {
    }

public:
    // 静态成员函数,用于获取单例实例
    static Singleton* getInstance() {
        if (instance == nullptr) {
            instance = new Singleton();  // 第一次访问时创建
        }
        return instance;
    }

    void setData(int val) {
        data = val;
    }

    int getData() const {
        return data;
    }
};

// 静态成员变量需要在类外初始化
Singleton* Singleton::instance = nullptr;

int main() {
    Singleton* s1 = Singleton::getInstance();
    Singleton* s2 = Singleton::getInstance();
    s1->setData(525);
    cout << "s1:" << s1->getData() << endl;
    cout << "s2:" << s1->getData() << endl;
    return 0;
}
~~~

* 线程安全问题解决：

  * 1.上锁使用lock()函数

  * 2.synchronized 

  * 3.局部静态变量

    ![image-20230925222821662](https://img-blog.csdnimg.cn/560418d2a9a046478e1e528181db1eb5.png)







---

* 饿汉式设计模式

  > 在应用程序**启动时立即创建实例**，不管是否需要使用。这样可以确保在任何时候都有一个实例可用
  >
  > 若存在多个单例对象且这几个单例对象互相依赖，可能出现程序崩溃的危险
  >
  > ​	原因：**静态成员的初始化顺序和析构顺序是未定义的行为**

  * main函数执行之前全局作用域的类成员静态变量已经初始化，**故没有多线程问题**
  * 

~~~cpp
#include <iostream>
using namespace std;

class Singleton {
private:
    static Singleton* instance;
    int data;
    Singleton() : data(0) {
    }

public:
    void setData(int val){
        data = val;
    }

    int getData(){
        return data;
    }

    static Singleton* getInstance(){
        return instance;
    }
};

Singleton* Singleton::instance = new Singleton();

int main(){
    Singleton* obj1 = Singleton::getInstance();
    Singleton* obj2 = Singleton::getInstance();

    obj1->setData(42);
    std::cout << "Data from obj1: " << obj1->getData() << std::endl; // 输出 42
    std::cout << "Data from obj2: " << obj2->getData() << std::endl; // 输出 42

    return 0;
}
~~~

* 懒汉和饿汉实现只有细微差别(多久初始化)

---

### 工厂设计模式

> 定义一个**创建对象的接口**，让**子类决定实例化哪个类**，而**对象的创建统一交由工厂区生产**

* 工厂设计模式的分类

  * 简单工厂模式
  * 工厂方法模式
  * 抽象工厂模式

  ---

* **简单工厂模式**

  * 主要特点是需要**在工厂类中做判断**，从而创造相应的产品。当**增加新的产品时，就需要修改工厂类**

  ![image-20230926074104384](https://img-blog.csdnimg.cn/809380519cec4571b4e2d6a40eb23045.png)

  * 优点：
    * 使用者不需要知道如何创建对象，降低系统耦合性
  * 缺点
    * 违反了开放封闭原则。对扩展开放，对修改封闭
  
* 简单工厂的UML图

  ![image-20230926203728994](https://img-blog.csdnimg.cn/e2df6467109344ab8845891878a91cde.png)

  

---

* **工厂方法模式**

  * 定义一个用于创建对象的接口，让子类决定实例化哪一个类。**Factory Method使一个类的实例化延迟到其子类**。

  ![image-20230926074949371](https://img-blog.csdnimg.cn/076121ded6f94d169350672637da4b34.png)

  * 优点	
    * 扩展性好，符合了开闭原则。新增一种产品时，只需要增加对应的产品类和对应的工厂子类即可
  * 缺点
    * 每增加一种产品，就需要增加一个对象的工厂。如果这家公司发展迅速，推出了很多新的处理器核，那么就要开设相应的新工厂。在C++实现中，就是要定义一个个的工厂类。显然，相比简单工厂模式，工厂方法模式需要更多的类定义。
  
* 工程方法的UML图

  ![image-20230926204349944](https://img-blog.csdnimg.cn/3e3499cae90449fe8e2a9978722f100e.png)

---

* 抽象工厂模式

  * 它的定义为提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

  ![image-20230926080407941](https://img-blog.csdnimg.cn/6d9d73fe5f3b4975ab6c9c7d778fc290.png)


* 抽象工厂模式的UML图

  ![image-20230926204424468](https://img-blog.csdnimg.cn/53e5007b2cb74fbeb9cd5fdd3b4ab859.png)

---

### 装饰器模式

> 指在**不改变现有对象结构的情况下，动态的给对象增加一些职责**(一些额外的功能)的模式

* 优点：
  * 装饰器是继承的有力补充，**比继承灵活**，在不改变原有对象的情况下，动态的给一个对象扩展功能，**即插即用**
  * 通过使用不用装饰类及这些装饰类的排列组合，可以实现不同效果
  * 装饰器模式完全**遵守开闭原则**
* 缺点
  * 装饰模式会增加许多子类，过度使用会使程序变得负责
* 装饰模式的结构与实现
  * 通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用**组合关系**来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是**装饰模式**的目标。
* 装饰模式主要包含以下角色：
  * 抽象构建(component)角色：
    * 定义一个抽象接口以规范准备接收附加责任的对象
  * 具体构建(concrete component)角色：
    * 实现抽象构建，通过装饰角色为其添加一些职责
  * 抽象装饰（Decorator）角色：
    * 继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。
  * 具体装饰（ConcreteDecorator）角色：
    * 实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。

![image-20230926211502223](E:\Typora\pictures\image-20230926211502223.png)

















> 下面是八股文部分

---

## 八股文(总结)

- [ ] **TCP和UDP的区别**

* TCP:

> TCP是**面向连接(三次握手，四次挥手)的协议**，只能进行**点对点**的通信，面向**字节流**
>
> ​	面向字节流是以字节为单位发送数据，并且一个数据包可以以字节大小来拆分成多个数据包，以方便发送。
>
> TCP**首部有20字节**
>
> TCP**有流量控制和拥塞控制**，确保数据的可靠性

* UCP

> UDP无连接**，面向数据报**
>
> 支持**一对一、一对多、多对多**
>
> 每次都需要发送固定长度的数据包
>
> UDP**首部有8个字节**

---

- [ ] **智能指针和指针的区别**

* 智能指针 shared_ptr，unique_ptr，weak_ptr

> new从堆区分配内存，不需要时需要使用delete释放。智能指针可以自动完成这个过程。c++11新增三种智能指针：unique_ptr，shared_ptr，weak_ptr
>
> * std::shared_ptr：共享指针，**用于多个指针共享同一块内存资源。**它使用引用计数来跟踪有多少个shared_ptr指向同一块内存。只有当所有的shared_ptr都销毁或者赋值为nullptr时，才会释放内存
> * std::unique_ptr：独占指针，用于表示独占所有权的指针。**每个unique_ptr拥有对内存资源的唯一所有权**，当unique_ptr被销毁或者转移所有权给另一个unique_ptr时，内存资源会被释放
> * 用于管理动态分配的内存资源，只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造, 它的构造和析构不会引起引用记数的增加或减少。它用于解决 std::shared_ptr可能引发的**循环引用(死锁)**问题。std::weak_ptr 允许你观测到一个由 std::shared_ptr 管理的对象，但不会影响到其引用计数。

~~~cpp
#include <iostream>
#include <memory>

class B; // 前置声明

class A {
public:
    std::shared_ptr<B> b_ptr; // A持有B的shared_ptr
};

class B {
public:
    std::weak_ptr<A> a_weak_ptr; // B持有A的weak_ptr
};

int main() {
    std::shared_ptr<A> a = std::make_shared<A>();
    std::shared_ptr<B> b = std::make_shared<B>();

    a->b_ptr = b; // A持有B的shared_ptr
    b->a_weak_ptr = a; // B持有A的weak_ptr

    // 此时a和b相互引用，但不会导致循环引用的问题，因为B持有的是weak_ptr

    // 在需要访问A或B时，需要先将weak_ptr转换为shared_ptr，并检查是否有效
    if (std::shared_ptr<A> a_shared = b->a_weak_ptr.lock()) {
        // 可以安全地访问A
    }

    return 0;
}

~~~

* 弄懂weak_ptr对shared_ptr的影响
* unique_ptr实现原理
  * **实现原理：**将**拷贝构造函数**和**赋值拷贝构造函数**申明为**private或delete。**不允许拷贝构造函数和赋值操作符，但是支持移动构造函数，通过std:move把一个对象指针变成右值之后可以移动给另一个unique_ptr
* shared_ptr实现原理
  * **实现原理：**有一个**引用计数的指针类型变量**，专门用于引用计数，使用拷贝构造函数和赋值拷贝构造函数时，引用计数加1，当引用计数为0时，释放资源
* **weak_ptr 能不能知道对象计数为 0，为什么？**

> 不能，weak_ptr是一种不控制对象生命周期的智能指针，它指向一个shared_ptr管理的对象，对对象进行管理的是shared_ptr。weak_ptr只是为了配合shared_ptr工作，**只可以从一个shared_ptr或者另一个weak_ptr构造**。
>
> 它不维护对象的引用计数，只跟踪对象是否还存在

* **weak_ptr 如何解决 shared_ptr 的循环引用问题？**

> * 在需要相互引用的对象中，使用weak_ptr来保存另一个对象的弱引用。
> * 必要时，将shared_ptr赋值给weak_ptr
> * 当需要访问互相引用的对象时，首先使用weak_ptr获取shared_ptr，然后**检查是否成功(是否被释放)**，从而避免非法访问
>   * shared_ptr  = weak_ptr.lock()

---

- [ ] **为什么使用智能指针**

> 1.new的内存需要使用delete释放。手动释放不能解决所有问题，比如在某个**全局函数中new**。此时，智能指针就派上了用场。使用智能指针可以很大程度上避免这个问题，因为**智能指针就是一个类**，当超出了类的作用域时，类会自动调用析构函数，析构函数会自动释放资源。所以，智能指针**的作用原理就是在函数结束时自动释放内存空间**，避免了手动释放内存空间。

---

- [ ] **右值**

> 右值没有名称，只能借助引用的方式使用，当想要修改右值时，常量左值是做不到的
>
> 所以c++11引入&& ，称为右值引用

* **注意：**
  * 和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，
  * 和常量左值引用不同的是，右值引用还可以对右值进行修改

---

- [ ] #### 指针和引用

* 指针：

  > 指针是一个**变量**，这个变量存储的是一个地址，指向内存的一个存储单元

* 引用

  > 引用跟原来的变量实质上是同一个东西，是**原变量的一个别名**，不能脱离被引用的对象而独立存在
  >
  > 引用的本质是一个**指针常量** T* const
  >
  > ​	一旦指向某一个单元就不能再指向别处





